// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.17/esri/copyright.txt for details.
//>>built
define("require exports tslib ../output/ReadLinearDepth.glsl ./Reprojection.glsl ../../shaderModules/interfaces".split(" "),function(m,b,g,h,d,k){function e(a,l){a.fragment.uniforms.add("nearFar","vec2");a.fragment.uniforms.add("depthMapView","sampler2D");a.fragment.uniforms.add("ssrViewMat","mat4");a.fragment.uniforms.add("invResolutionHeight","float");a.include(h.ReadLinearDepth);a.include(d.Reprojection);a.fragment.code.add(k.glsl(f||(f=g.__makeTemplateObject(["\n  const int maxSteps \x3d ","\n\n  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)\n  {\n    vec4 projectedCoord \x3d  projectionMat * vec4(x, 1.0);\n    projectedCoord.xy /\x3d projectedCoord.w;\n    projectedCoord.xy \x3d projectedCoord.xy*0.5 + 0.5;\n    return projectedCoord;\n  }\n\n  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)\n  {\n    vec3 viewPos \x3d startPosition;\n    vec3 viewPosEnd \x3d startPosition;\n\n    // Project the start position to the screen\n    vec4 projectedCoordStart \x3d applyProjectionMat(rpProjectionMat, viewPos);\n    vec3  Q0 \x3d viewPos / projectedCoordStart.w; // homogeneous camera space\n    float k0 \x3d 1.0/ projectedCoordStart.w;\n\n    // advance the position in the direction of the reflection\n    viewPos +\x3d dir;\n\n    vec4 projectedCoordVanishingPoint \x3d applyProjectionMat(rpProjectionMat, dir);\n\n    // Project the advanced position to the screen\n    vec4 projectedCoordEnd \x3d applyProjectionMat(rpProjectionMat, viewPos);\n    vec3  Q1 \x3d viewPos / projectedCoordEnd.w; // homogeneous camera space\n    float k1 \x3d 1.0/ projectedCoordEnd.w;\n\n    // calculate the reflection direction in the screen space\n    vec2 projectedCoordDir \x3d (projectedCoordEnd.xy - projectedCoordStart.xy);\n    vec2 projectedCoordDistVanishingPoint \x3d (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);\n\n    float yMod \x3d min(abs(projectedCoordDistVanishingPoint.y), 1.0);\n\n    float projectedCoordDirLength \x3d length(projectedCoordDir);\n    float maxSt \x3d float(maxSteps);\n\n    // normalize the projection direction depending on maximum steps\n    // this determines how blocky the reflection looks\n    vec2 dP \x3d yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);\n\n    // Normalize the homogeneous camera space coordinates\n    vec3  dQ \x3d yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);\n    float dk \x3d yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);\n\n    // initialize the variables for ray marching\n    vec2 P \x3d projectedCoordStart.xy;\n    vec3 Q \x3d Q0;\n    float k \x3d k0;\n    float rayStartZ \x3d -startPosition.z; // estimated ray start depth value\n    float rayEndZ \x3d -startPosition.z;   // estimated ray end depth value\n    float prevEstimateZ \x3d -startPosition.z;\n    float rayDiffZ \x3d 0.0;\n    float dDepth;\n    float depth;\n    float rayDiffZOld \x3d 0.0;\n\n    // early outs\n    if (dot(normal, dir) \x3c 0.0 || dot(-viewDir, normal) \x3c 0.0)\n      return vec3(P, 0.0);\n\n    for(int i \x3d 0; i \x3c maxSteps-1; i++)\n    {\n      depth \x3d -linearDepthFromTexture(depthMapView, P, nearFar); // get linear depth from the depth buffer\n\n      // estimate depth of the marching ray\n      rayStartZ \x3d prevEstimateZ;\n      dDepth \x3d -rayStartZ - depth;\n      rayEndZ \x3d (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));\n      rayDiffZ \x3d rayEndZ- rayStartZ;\n      prevEstimateZ \x3d rayEndZ;\n\n      if(-rayEndZ \x3e nearFar[1] || -rayEndZ \x3c nearFar[0] || P.y \x3c 0.0  || P.y \x3e 1.0 )\n      {\n        return vec3(P, 0.);\n      }\n\n      // If we detect a hit - return the intersection point, two conditions:\n      //  - dDepth \x3e 0.0 - sampled point depth is in front of estimated depth\n      //  - if difference between dDepth and rayDiffZOld is not too large\n      //  - if difference between dDepth and 0.025/abs(k) is not too large\n      //  - if the sampled depth is not behind far plane or in front of near plane\n\n      if((dDepth) \x3c 0.025/abs(k) + abs(rayDiffZ) \x26\x26 dDepth \x3e 0.0 \x26\x26 depth \x3e nearFar[0] \x26\x26 depth \x3c nearFar[1] \x26\x26 abs(P.y - projectedCoordStart.y) \x3e invResolutionHeight)\n      {\n          return vec3(P, depth);\n      }\n\n      // continue with ray marching\n      P +\x3d dP;\n      Q.z +\x3d dQ.z;\n      k +\x3d dk;\n      rayDiffZOld \x3d rayDiffZ;\n    }\n    return vec3(P, 0.0);\n  }\n  "],
["\n  const int maxSteps \x3d ","\n\n  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)\n  {\n    vec4 projectedCoord \x3d  projectionMat * vec4(x, 1.0);\n    projectedCoord.xy /\x3d projectedCoord.w;\n    projectedCoord.xy \x3d projectedCoord.xy*0.5 + 0.5;\n    return projectedCoord;\n  }\n\n  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)\n  {\n    vec3 viewPos \x3d startPosition;\n    vec3 viewPosEnd \x3d startPosition;\n\n    // Project the start position to the screen\n    vec4 projectedCoordStart \x3d applyProjectionMat(rpProjectionMat, viewPos);\n    vec3  Q0 \x3d viewPos / projectedCoordStart.w; // homogeneous camera space\n    float k0 \x3d 1.0/ projectedCoordStart.w;\n\n    // advance the position in the direction of the reflection\n    viewPos +\x3d dir;\n\n    vec4 projectedCoordVanishingPoint \x3d applyProjectionMat(rpProjectionMat, dir);\n\n    // Project the advanced position to the screen\n    vec4 projectedCoordEnd \x3d applyProjectionMat(rpProjectionMat, viewPos);\n    vec3  Q1 \x3d viewPos / projectedCoordEnd.w; // homogeneous camera space\n    float k1 \x3d 1.0/ projectedCoordEnd.w;\n\n    // calculate the reflection direction in the screen space\n    vec2 projectedCoordDir \x3d (projectedCoordEnd.xy - projectedCoordStart.xy);\n    vec2 projectedCoordDistVanishingPoint \x3d (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);\n\n    float yMod \x3d min(abs(projectedCoordDistVanishingPoint.y), 1.0);\n\n    float projectedCoordDirLength \x3d length(projectedCoordDir);\n    float maxSt \x3d float(maxSteps);\n\n    // normalize the projection direction depending on maximum steps\n    // this determines how blocky the reflection looks\n    vec2 dP \x3d yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);\n\n    // Normalize the homogeneous camera space coordinates\n    vec3  dQ \x3d yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);\n    float dk \x3d yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);\n\n    // initialize the variables for ray marching\n    vec2 P \x3d projectedCoordStart.xy;\n    vec3 Q \x3d Q0;\n    float k \x3d k0;\n    float rayStartZ \x3d -startPosition.z; // estimated ray start depth value\n    float rayEndZ \x3d -startPosition.z;   // estimated ray end depth value\n    float prevEstimateZ \x3d -startPosition.z;\n    float rayDiffZ \x3d 0.0;\n    float dDepth;\n    float depth;\n    float rayDiffZOld \x3d 0.0;\n\n    // early outs\n    if (dot(normal, dir) \x3c 0.0 || dot(-viewDir, normal) \x3c 0.0)\n      return vec3(P, 0.0);\n\n    for(int i \x3d 0; i \x3c maxSteps-1; i++)\n    {\n      depth \x3d -linearDepthFromTexture(depthMapView, P, nearFar); // get linear depth from the depth buffer\n\n      // estimate depth of the marching ray\n      rayStartZ \x3d prevEstimateZ;\n      dDepth \x3d -rayStartZ - depth;\n      rayEndZ \x3d (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));\n      rayDiffZ \x3d rayEndZ- rayStartZ;\n      prevEstimateZ \x3d rayEndZ;\n\n      if(-rayEndZ \x3e nearFar[1] || -rayEndZ \x3c nearFar[0] || P.y \x3c 0.0  || P.y \x3e 1.0 )\n      {\n        return vec3(P, 0.);\n      }\n\n      // If we detect a hit - return the intersection point, two conditions:\n      //  - dDepth \x3e 0.0 - sampled point depth is in front of estimated depth\n      //  - if difference between dDepth and rayDiffZOld is not too large\n      //  - if difference between dDepth and 0.025/abs(k) is not too large\n      //  - if the sampled depth is not behind far plane or in front of near plane\n\n      if((dDepth) \x3c 0.025/abs(k) + abs(rayDiffZ) \x26\x26 dDepth \x3e 0.0 \x26\x26 depth \x3e nearFar[0] \x26\x26 depth \x3c nearFar[1] \x26\x26 abs(P.y - projectedCoordStart.y) \x3e invResolutionHeight)\n      {\n          return vec3(P, depth);\n      }\n\n      // continue with ray marching\n      P +\x3d dP;\n      Q.z +\x3d dQ.z;\n      k +\x3d dk;\n      rayDiffZOld \x3d rayDiffZ;\n    }\n    return vec3(P, 0.0);\n  }\n  "])),
l.highStepCount?"150;":"75;"))}Object.defineProperty(b,"__esModule",{value:!0});b.ScreenSpaceReflections=void 0;b.ScreenSpaceReflections=e;(function(a){a.bindUniforms=function(a,b,c){c.ssrEnabled&&(a.setUniform1i("depthMapView",c.linearDepthTextureID),b.bindTexture(c.linearDepthTexture,c.linearDepthTextureID),a.setUniform2fv("nearFar",c.camera.nearFar),a.setUniformMatrix4fv("ssrViewMat",c.camera.viewMatrix),a.setUniform1f("invResolutionHeight",1/c.camera.height),d.Reprojection.bindUniforms(a,b,c))}})(e=
b.ScreenSpaceReflections||(b.ScreenSpaceReflections={}));var f});