// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.17/esri/copyright.txt for details.
//>>built
define("require exports tslib ./BasicGrid.glsl ./Colormap.glsl ./Common.glsl ../util/ColorConversion.glsl ../../shaderModules/interfaces ../../shaderModules/ShaderBuilder".split(" "),function(y,e,c,t,u,v,w,d,x){Object.defineProperty(e,"__esModule",{value:!0});e.build=void 0;e.build=function(b){var a=new x.ShaderBuilder;a.include(t.BasicGrid);a.include(v.Common);a.include(u.Colormap);0===b.output?(b=b.applyColormap,a.fragment.uniforms.add("u_bandCount","int"),a.fragment.uniforms.add("u_minCutOff",
"float",3),a.fragment.uniforms.add("u_maxCutOff","float",3),a.fragment.uniforms.add("u_factor","float",3),a.fragment.uniforms.add("u_minOutput","float"),a.fragment.uniforms.add("u_maxOutput","float"),a.fragment.uniforms.add("u_useGamma","bool"),a.fragment.uniforms.add("u_gamma","float",3),a.fragment.uniforms.add("u_gammaCorrection","float",3),a.fragment.code.add(d.glsl(f||(f=c.__makeTemplateObject(["\n      float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\n        // clamp values\n        if (val \x3e\x3d maxCutOff) {\n          return maxOutput;\n        } else if (val \x3c\x3d minCutOff) {\n          return minOutput;\n        }\n\n        // stretch a single value based on whether to use gamma\n        float stretchedVal;\n        if (useGamma) {\n          float tempf \x3d 1.0;\n          float outRange \x3d maxOutput - minOutput;\n          float relativeVal \x3d (val - minCutOff) / (maxCutOff - minCutOff);\n          if (gamma \x3e 1.0) {\n            tempf -\x3d pow(1.0 / outRange, relativeVal * gammaCorrection);\n          }\n          stretchedVal \x3d (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n        } else {\n          stretchedVal \x3d minOutput + (val - minCutOff) * factor;\n        }\n        return stretchedVal;\n      }\n    "],
["\n      float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\n        // clamp values\n        if (val \x3e\x3d maxCutOff) {\n          return maxOutput;\n        } else if (val \x3c\x3d minCutOff) {\n          return minOutput;\n        }\n\n        // stretch a single value based on whether to use gamma\n        float stretchedVal;\n        if (useGamma) {\n          float tempf \x3d 1.0;\n          float outRange \x3d maxOutput - minOutput;\n          float relativeVal \x3d (val - minCutOff) / (maxCutOff - minCutOff);\n          if (gamma \x3e 1.0) {\n            tempf -\x3d pow(1.0 / outRange, relativeVal * gammaCorrection);\n          }\n          stretchedVal \x3d (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n        } else {\n          stretchedVal \x3d minOutput + (val - minCutOff) * factor;\n        }\n        return stretchedVal;\n      }\n    "])))),
b=b?d.glsl(g||(g=c.__makeTemplateObject(["gl_FragColor \x3d colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma);"],["gl_FragColor \x3d colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma);"]))):d.glsl(h||(h=c.__makeTemplateObject(["gl_FragColor \x3d vec4(grayVal, grayVal, grayVal, 1.0) * currentPixel.a * u_opacity;"],["gl_FragColor \x3d vec4(grayVal, grayVal, grayVal, 1.0) * currentPixel.a * u_opacity;"]))),a.fragment.code.add(d.glsl(k||(k=c.__makeTemplateObject(["\n      void main() {\n        vec2 pixelLocation \x3d getPixelLocation(v_texcoord);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        vec4 currentPixel \x3d getPixel(pixelLocation);\n        if (currentPixel.a \x3d\x3d 0.0) {\n          gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        if (u_bandCount \x3d\x3d 1) {\n          float grayVal \x3d stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          ",
"\n        } else {\n          float redVal \x3d stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          float greenVal \x3d stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\n          float blueVal \x3d stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\n          gl_FragColor \x3d vec4(redVal, greenVal, blueVal, 1.0) * currentPixel.a * u_opacity;\n        }\n      }\n    "],
["\n      void main() {\n        vec2 pixelLocation \x3d getPixelLocation(v_texcoord);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        vec4 currentPixel \x3d getPixel(pixelLocation);\n        if (currentPixel.a \x3d\x3d 0.0) {\n          gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        if (u_bandCount \x3d\x3d 1) {\n          float grayVal \x3d stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          ",
"\n        } else {\n          float redVal \x3d stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          float greenVal \x3d stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\n          float blueVal \x3d stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\n          gl_FragColor \x3d vec4(redVal, greenVal, blueVal, 1.0) * currentPixel.a * u_opacity;\n        }\n      }\n    "])),
b))):1===b.output?a.fragment.code.add(d.glsl(l||(l=c.__makeTemplateObject(["\n      void main() {\n        // get pixel location\n        vec2 pixelLocation \x3d getPixelLocation(v_texcoord);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        vec4 currentPixel \x3d getPixel(pixelLocation);\n        // apply colormap we use float texture here\n        gl_FragColor \x3d colormap(currentPixel, true);\n      }\n    "],
["\n      void main() {\n        // get pixel location\n        vec2 pixelLocation \x3d getPixelLocation(v_texcoord);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        vec4 currentPixel \x3d getPixel(pixelLocation);\n        // apply colormap we use float texture here\n        gl_FragColor \x3d colormap(currentPixel, true);\n      }\n    "])))):2===b.output&&(b=b.applyColormap,a.fragment.uniforms.add("u_hillshadeType",
"int"),a.fragment.uniforms.add("u_sinZcosAs","float",6),a.fragment.uniforms.add("u_sinZsinAs","float",6),a.fragment.uniforms.add("u_cosZs","float",6),a.fragment.uniforms.add("u_weights","float",6),a.fragment.uniforms.add("u_factor","vec2"),a.fragment.uniforms.add("u_applyColormap","bool"),a.fragment.uniforms.add("u_minValue","float"),a.fragment.uniforms.add("u_maxValue","float"),a.fragment.uniforms.add("u_srcImageSize","vec2"),a.fragment.include(w.ColorConversion),a.fragment.code.add(d.glsl(m||(m=
c.__makeTemplateObject(["\n  vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {\n    val \x3d clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\n    vec4 rgb \x3d colormap(vec4(val, val, val, 1.0), false);\n    vec3 hsv \x3d rgb2hsv(rgb.xyz);\n    hsv.z \x3d hillshade;\n    return vec4(hsv2rgb(hsv) * alpha, alpha);\n  }\n"],["\n  vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {\n    val \x3d clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\n    vec4 rgb \x3d colormap(vec4(val, val, val, 1.0), false);\n    vec3 hsv \x3d rgb2hsv(rgb.xyz);\n    hsv.z \x3d hillshade;\n    return vec4(hsv2rgb(hsv) * alpha, alpha);\n  }\n"])))),
a.fragment.code.add(d.glsl(n||(n=c.__makeTemplateObject(["\n    float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\n      if (a \x3d\x3d 0.0 || a \x3d\x3d 0.0 || a\x3d\x3d0.0 || a \x3d\x3d 0.0 || a \x3d\x3d 0.0 || a\x3d\x3d0.0 || a \x3d\x3d 0.0 || a \x3d\x3d 0.0 || a\x3d\x3d0.0) {\n        return 0.0;\n      }  else {\n        return e;\n      }\n    }\n  "],["\n    float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\n      if (a \x3d\x3d 0.0 || a \x3d\x3d 0.0 || a\x3d\x3d0.0 || a \x3d\x3d 0.0 || a \x3d\x3d 0.0 || a\x3d\x3d0.0 || a \x3d\x3d 0.0 || a \x3d\x3d 0.0 || a\x3d\x3d0.0) {\n        return 0.0;\n      }  else {\n        return e;\n      }\n    }\n  "])))),
b=b?d.glsl(p||(p=c.__makeTemplateObject(["gl_FragColor \x3d overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha);"],["gl_FragColor \x3d overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha);"]))):d.glsl(q||(q=c.__makeTemplateObject(["\n       hillshade *\x3d alpha;\n       gl_FragColor \x3d vec4(hillshade, hillshade, hillshade, alpha);\n       "],["\n       hillshade *\x3d alpha;\n       gl_FragColor \x3d vec4(hillshade, hillshade, hillshade, alpha);\n       "]))),a.fragment.code.add(d.glsl(r||
(r=c.__makeTemplateObject(["\n    void main() {\n      vec2 pixelLocation \x3d getPixelLocation(v_texcoord);\n      if (isOutside(pixelLocation)) {\n        gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n\n      vec4 currentPixel \x3d getPixel(pixelLocation);\n      if (currentPixel.a \x3d\x3d 0.0) {\n        gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n\n      //mirror edge pixels\n      vec2 axy \x3d vec2(-1.0, -1.0);\n      vec2 bxy \x3d vec2(0.0, -1.0);\n      vec2 cxy \x3d vec2(1.0, -1.0);\n      vec2 dxy \x3d vec2(-1.0, 0.0);\n      vec2 fxy \x3d vec2(1.0, 0.0);\n      vec2 gxy \x3d vec2(-1.0, 1.0);\n      vec2 hxy \x3d vec2(0.0, 1.0);\n      vec2 ixy \x3d vec2(1.0, 1.0);\n      vec2 onePixel \x3d 1.0 / u_srcImageSize;\n      if (pixelLocation.s \x3c onePixel.s) {\n        axy[0] \x3d 1.0;\n        dxy[0] \x3d 1.0;\n        gxy[0] \x3d 1.0;\n      }\n      if (pixelLocation.t \x3c onePixel.t) {\n        axy[1] \x3d 1.0;\n        bxy[1] \x3d 1.0;\n        cxy[1] \x3d 1.0;\n      }\n      if (pixelLocation.s \x3e 1.0 - onePixel.s) {\n        cxy[0] \x3d -1.0;\n        fxy[0] \x3d -1.0;\n        ixy[0] \x3d -1.0;\n      }\n      if (pixelLocation.t \x3e 1.0 - onePixel.t) {\n        gxy[1] \x3d -1.0;\n        hxy[1] \x3d -1.0;\n        ixy[1] \x3d -1.0;\n      }\n\n      // calculate hillshade\n      vec4 va \x3d texture2D(u_image, pixelLocation + onePixel * axy);\n      vec4 vb \x3d texture2D(u_image, pixelLocation + onePixel * bxy);\n      vec4 vc \x3d texture2D(u_image, pixelLocation + onePixel * cxy);\n      vec4 vd \x3d texture2D(u_image, pixelLocation + onePixel * dxy);\n      vec4 ve \x3d texture2D(u_image, pixelLocation);\n      vec4 vf \x3d texture2D(u_image, pixelLocation + onePixel * fxy);\n      vec4 vg \x3d texture2D(u_image, pixelLocation + onePixel * gxy);\n      vec4 vh \x3d texture2D(u_image, pixelLocation + onePixel * hxy);\n      vec4 vi \x3d texture2D(u_image, pixelLocation + onePixel * ixy);\n\n      // calculate the rate of z change along the x, y, and diagonal direction\n      float dzx \x3d (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\n      float dzy \x3d (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\n      float dzd \x3d sqrt(1.0 + dzx * dzx + dzy * dzy);\n      float hillshade \x3d 0.0;\n\n      // traditional single light source\n      if (u_hillshadeType \x3d\x3d 0){\n        float cosDelta \x3d u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\n        float z \x3d (u_cosZs[0] + cosDelta) / dzd;\n        if (z \x3c 0.0)  z \x3d 0.0;\n        hillshade \x3d z;\n      } else {\n        // multi-directional with 6 light sources\n        for (int k \x3d 0; k \x3c 6; k++) {\n        float cosDelta \x3d u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\n        float z \x3d (u_cosZs[k] + cosDelta) / dzd;\n        if (z \x3c 0.0) z \x3d 0.0;\n        hillshade \x3d hillshade + z * u_weights[k];\n        if (k \x3d\x3d 5) break;\n        }\n      }\n\n      // set color\n      float alpha \x3d getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n      alpha *\x3d u_opacity;\n      ",
"\n    }\n  "],["\n    void main() {\n      vec2 pixelLocation \x3d getPixelLocation(v_texcoord);\n      if (isOutside(pixelLocation)) {\n        gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n\n      vec4 currentPixel \x3d getPixel(pixelLocation);\n      if (currentPixel.a \x3d\x3d 0.0) {\n        gl_FragColor \x3d vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n\n      //mirror edge pixels\n      vec2 axy \x3d vec2(-1.0, -1.0);\n      vec2 bxy \x3d vec2(0.0, -1.0);\n      vec2 cxy \x3d vec2(1.0, -1.0);\n      vec2 dxy \x3d vec2(-1.0, 0.0);\n      vec2 fxy \x3d vec2(1.0, 0.0);\n      vec2 gxy \x3d vec2(-1.0, 1.0);\n      vec2 hxy \x3d vec2(0.0, 1.0);\n      vec2 ixy \x3d vec2(1.0, 1.0);\n      vec2 onePixel \x3d 1.0 / u_srcImageSize;\n      if (pixelLocation.s \x3c onePixel.s) {\n        axy[0] \x3d 1.0;\n        dxy[0] \x3d 1.0;\n        gxy[0] \x3d 1.0;\n      }\n      if (pixelLocation.t \x3c onePixel.t) {\n        axy[1] \x3d 1.0;\n        bxy[1] \x3d 1.0;\n        cxy[1] \x3d 1.0;\n      }\n      if (pixelLocation.s \x3e 1.0 - onePixel.s) {\n        cxy[0] \x3d -1.0;\n        fxy[0] \x3d -1.0;\n        ixy[0] \x3d -1.0;\n      }\n      if (pixelLocation.t \x3e 1.0 - onePixel.t) {\n        gxy[1] \x3d -1.0;\n        hxy[1] \x3d -1.0;\n        ixy[1] \x3d -1.0;\n      }\n\n      // calculate hillshade\n      vec4 va \x3d texture2D(u_image, pixelLocation + onePixel * axy);\n      vec4 vb \x3d texture2D(u_image, pixelLocation + onePixel * bxy);\n      vec4 vc \x3d texture2D(u_image, pixelLocation + onePixel * cxy);\n      vec4 vd \x3d texture2D(u_image, pixelLocation + onePixel * dxy);\n      vec4 ve \x3d texture2D(u_image, pixelLocation);\n      vec4 vf \x3d texture2D(u_image, pixelLocation + onePixel * fxy);\n      vec4 vg \x3d texture2D(u_image, pixelLocation + onePixel * gxy);\n      vec4 vh \x3d texture2D(u_image, pixelLocation + onePixel * hxy);\n      vec4 vi \x3d texture2D(u_image, pixelLocation + onePixel * ixy);\n\n      // calculate the rate of z change along the x, y, and diagonal direction\n      float dzx \x3d (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\n      float dzy \x3d (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\n      float dzd \x3d sqrt(1.0 + dzx * dzx + dzy * dzy);\n      float hillshade \x3d 0.0;\n\n      // traditional single light source\n      if (u_hillshadeType \x3d\x3d 0){\n        float cosDelta \x3d u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\n        float z \x3d (u_cosZs[0] + cosDelta) / dzd;\n        if (z \x3c 0.0)  z \x3d 0.0;\n        hillshade \x3d z;\n      } else {\n        // multi-directional with 6 light sources\n        for (int k \x3d 0; k \x3c 6; k++) {\n        float cosDelta \x3d u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\n        float z \x3d (u_cosZs[k] + cosDelta) / dzd;\n        if (z \x3c 0.0) z \x3d 0.0;\n        hillshade \x3d hillshade + z * u_weights[k];\n        if (k \x3d\x3d 5) break;\n        }\n      }\n\n      // set color\n      float alpha \x3d getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n      alpha *\x3d u_opacity;\n      ",
"\n    }\n  "])),b)));return a};var l,f,g,h,k,m,n,p,q,r});