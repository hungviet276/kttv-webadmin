// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.17/esri/copyright.txt for details.
//>>built
define("require exports tslib ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/Transform.glsl ../core/shaderLibrary/attributes/VertexColor.glsl ../core/shaderLibrary/output/OutputHighlight.glsl ../core/shaderLibrary/util/AlphaDiscard.glsl ../core/shaderModules/interfaces ../core/shaderModules/ShaderBuilder".split(" "),function(H,e,d,A,B,C,D,E,b,F){function G(c){function a(a){return c.draped?b.glsl(f||(f=d.__makeTemplateObject(["coverage(vuv.",", texelSize)"],["coverage(vuv.",", texelSize)"])),
a):b.glsl(g||(g=d.__makeTemplateObject(["sample(vuv.",")"],["sample(vuv.",")"])),a)}switch(c.style){case 3:case 0:return a("y");case 4:case 1:return a("x");case 5:case 2:return b.glsl(h||(h=d.__makeTemplateObject(["\n        1.0 - (1.0 - ",") * (1.0 - ",")\n      "],["\n        1.0 - (1.0 - ",") * (1.0 - ",")\n      "])),a("x"),a("y"));default:return"0.0"}}Object.defineProperty(e,"__esModule",{value:!0});e.build=void 0;e.build=function(c){var a=new F.ShaderBuilder;c.draped||a.extensions.add("GL_OES_standard_derivatives");
a.include(B.Transform,{linearDepth:!1});a.include(C.VertexColor,c);a.vertex.uniforms.add("proj","mat4");a.vertex.uniforms.add("view","mat4");c.draped?a.vertex.uniforms.add("worldToScreenRatio","float"):(a.vertex.uniforms.add("worldToScreenPerDistanceRatio","float"),a.vertex.uniforms.add("camPos","vec3"),a.vertex.uniforms.add("viewForward","vec3"),a.attributes.add("bound1","vec3"),a.attributes.add("bound2","vec3"),a.attributes.add("bound3","vec3"));a.attributes.add("position","vec3");a.attributes.add("uvMapSpace",
"vec4");a.varyings.add("vpos","vec3");a.varyings.add("vuv","vec2");var e=3===c.style||4===c.style||5===c.style;e&&a.vertex.code.add(b.glsl(k||(k=d.__makeTemplateObject(["\n      const mat2 rotate45 \x3d mat2(",", ",",\n                                 ",", ",");\n    "],["\n      const mat2 rotate45 \x3d mat2(",", ",",\n                                 ",", ",");\n    "])),b.glsl.float(.70710678118),b.glsl.float(-.70710678118),b.glsl.float(.70710678118),b.glsl.float(.70710678118)));c.draped||(a.vertex.code.add(b.glsl(l||
(l=d.__makeTemplateObject(["\n      vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\n        float projectedLength \x3d dot(halfVector, point - center) / dot(halfVector, halfVector);\n        return center + halfVector * clamp(projectedLength, -1.0, 1.0);\n      }\n    "],["\n      vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\n        float projectedLength \x3d dot(halfVector, point - center) / dot(halfVector, halfVector);\n        return center + halfVector * clamp(projectedLength, -1.0, 1.0);\n      }\n    "])))),
a.vertex.code.add(b.glsl(m||(m=d.__makeTemplateObject(["\n      vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\n        float d \x3d dot(planeNormal, planePoint);\n        float t \x3d (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\n\n        return rayOrigin + t * rayDir;\n      }\n    "],["\n      vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\n        float d \x3d dot(planeNormal, planePoint);\n        float t \x3d (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\n\n        return rayOrigin + t * rayDir;\n      }\n    "])))),
a.vertex.code.add(b.glsl(n||(n=d.__makeTemplateObject(["\n      float boundingRectDistanceToCamera() {\n        vec3 halfU \x3d (bound2 - bound1) * 0.5;\n        vec3 halfV \x3d (bound3 - bound1) * 0.5;\n        vec3 center \x3d bound1 + halfU + halfV;\n        vec3 n \x3d normalize(cross(halfU, halfV));\n\n        vec3 viewDir \x3d viewForward;\n\n        float viewAngle \x3d dot(viewDir, n);\n        float minViewAngle \x3d ",";\n\n        if (abs(viewAngle) \x3c minViewAngle) {\n          // view direction is (almost) parallel to plane -\x3e clamp it to min angle\n          float normalComponent \x3d sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir \x3d normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected \x3d intersectRayPlane(viewDir, camPos, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected \x3d projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected \x3d projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint \x3d uProjected + vProjected - center;\n\n        return length(closestPoint - camPos);\n      }\n    "],
["\n      float boundingRectDistanceToCamera() {\n        vec3 halfU \x3d (bound2 - bound1) * 0.5;\n        vec3 halfV \x3d (bound3 - bound1) * 0.5;\n        vec3 center \x3d bound1 + halfU + halfV;\n        vec3 n \x3d normalize(cross(halfU, halfV));\n\n        vec3 viewDir \x3d viewForward;\n\n        float viewAngle \x3d dot(viewDir, n);\n        float minViewAngle \x3d ",";\n\n        if (abs(viewAngle) \x3c minViewAngle) {\n          // view direction is (almost) parallel to plane -\x3e clamp it to min angle\n          float normalComponent \x3d sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir \x3d normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected \x3d intersectRayPlane(viewDir, camPos, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected \x3d projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected \x3d projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint \x3d uProjected + vProjected - center;\n\n        return length(closestPoint - camPos);\n      }\n    "])),
b.glsl.float(.08715574274))));a.vertex.code.add(b.glsl(p||(p=d.__makeTemplateObject(["\n    vec2 scaledUV() {\n      vec2 uv \x3d uvMapSpace.xy ",";\n      vec2 uvCellOrigin \x3d uvMapSpace.zw ",";\n\n      ","\n\n      vec2 uvOffset \x3d mod(uvCellOrigin * ratio, ",");\n      return uvOffset + (uv * ratio);\n    }\n  "],["\n    vec2 scaledUV() {\n      vec2 uv \x3d uvMapSpace.xy ",";\n      vec2 uvCellOrigin \x3d uvMapSpace.zw ",";\n\n      ","\n\n      vec2 uvOffset \x3d mod(uvCellOrigin * ratio, ",
");\n      return uvOffset + (uv * ratio);\n    }\n  "])),e?" * rotate45":"",e?" * rotate45":"",c.draped?b.glsl(q||(q=d.__makeTemplateObject(["\n            float ratio \x3d worldToScreenRatio;\n          "],["\n            float ratio \x3d worldToScreenRatio;\n          "]))):b.glsl(r||(r=d.__makeTemplateObject(["\n            float distanceToCamera \x3d boundingRectDistanceToCamera();\n            float ratio \x3d worldToScreenPerDistanceRatio / distanceToCamera;\n\n            // Logarithmically discretize ratio to avoid jittering\n            float step \x3d 0.1;\n            ratio \x3d log(ratio);\n            ratio \x3d ceil(ratio / step) * step;\n            ratio \x3d exp(ratio);\n          "],
["\n            float distanceToCamera \x3d boundingRectDistanceToCamera();\n            float ratio \x3d worldToScreenPerDistanceRatio / distanceToCamera;\n\n            // Logarithmically discretize ratio to avoid jittering\n            float step \x3d 0.1;\n            ratio \x3d log(ratio);\n            ratio \x3d ceil(ratio / step) * step;\n            ratio \x3d exp(ratio);\n          "]))),b.glsl.float(c.patternSpacing)));a.vertex.code.add(b.glsl(t||(t=d.__makeTemplateObject(["\n    void main(void) {\n      vuv \x3d scaledUV();\n      vpos \x3d position;\n      forwardNormalizedVertexColor();\n      gl_Position \x3d transformPosition(proj, view, vpos);\n    }\n  "],
["\n    void main(void) {\n      vuv \x3d scaledUV();\n      vpos \x3d position;\n      forwardNormalizedVertexColor();\n      gl_Position \x3d transformPosition(proj, view, vpos);\n    }\n  "]))));a.include(A.Slice,c);a.fragment.uniforms.add("matColor","vec4");c.draped&&a.fragment.uniforms.add("texelSize","float");4===c.output&&a.include(D.OutputHighlight);0===c.output&&(a.fragment.code.add(b.glsl(u||(u=d.__makeTemplateObject(["\n      const float lineWidth \x3d ",";\n      const float spacing \x3d ",
";\n      const float spacingINV \x3d ",";\n\n      float coverage(float p, float txlSize) {\n        p \x3d mod(p, spacing);\n\n        float halfTxlSize \x3d txlSize / 2.0;\n\n        float start \x3d p - halfTxlSize;\n        float end \x3d p + halfTxlSize;\n\n        float coverage \x3d (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -\x3d min(lineWidth, mod(start, spacing));\n        coverage -\x3d max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    "],
["\n      const float lineWidth \x3d ",";\n      const float spacing \x3d ",";\n      const float spacingINV \x3d ",";\n\n      float coverage(float p, float txlSize) {\n        p \x3d mod(p, spacing);\n\n        float halfTxlSize \x3d txlSize / 2.0;\n\n        float start \x3d p - halfTxlSize;\n        float end \x3d p + halfTxlSize;\n\n        float coverage \x3d (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -\x3d min(lineWidth, mod(start, spacing));\n        coverage -\x3d max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    "])),
b.glsl.float(c.lineWidth),b.glsl.float(c.patternSpacing),b.glsl.float(1/c.patternSpacing))),c.draped||a.fragment.code.add(b.glsl(v||(v=d.__makeTemplateObject(["\n        const int maxSamples \x3d 5;\n\n        float sample(float p) {\n          vec2 dxdy \x3d abs(vec2(dFdx(p), dFdy(p)));\n          float fwidth \x3d dxdy.x + dxdy.y;\n\n          ivec2 samples \x3d 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\n          vec2 invSamples \x3d 1.0 / vec2(samples);\n\n          float accumulator \x3d 0.0;\n\n          for (int j \x3d 0; j \x3c maxSamples; j++) {\n            if(j \x3e\x3d samples.y) {\n              break;\n            }\n\n            for (int i \x3d 0; i \x3c maxSamples; i++) {\n              if(i \x3e\x3d samples.x) {\n                break;\n              }\n\n              vec2 step \x3d vec2(i,j) * invSamples - 0.5;\n              accumulator +\x3d coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n            }\n          }\n\n          accumulator /\x3d float(samples.x * samples.y);\n          return accumulator;\n        }\n      "],
["\n        const int maxSamples \x3d 5;\n\n        float sample(float p) {\n          vec2 dxdy \x3d abs(vec2(dFdx(p), dFdy(p)));\n          float fwidth \x3d dxdy.x + dxdy.y;\n\n          ivec2 samples \x3d 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\n          vec2 invSamples \x3d 1.0 / vec2(samples);\n\n          float accumulator \x3d 0.0;\n\n          for (int j \x3d 0; j \x3c maxSamples; j++) {\n            if(j \x3e\x3d samples.y) {\n              break;\n            }\n\n            for (int i \x3d 0; i \x3c maxSamples; i++) {\n              if(i \x3e\x3d samples.x) {\n                break;\n              }\n\n              vec2 step \x3d vec2(i,j) * invSamples - 0.5;\n              accumulator +\x3d coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n            }\n          }\n\n          accumulator /\x3d float(samples.x * samples.y);\n          return accumulator;\n        }\n      "])))));
a.fragment.code.add(b.glsl(w||(w=d.__makeTemplateObject(["\n    void main() {\n      discardBySlice(vpos);\n      vec4 color \x3d ","\n      color \x3d highlightSlice(color, vpos);\n\n      ","\n\n      if (color.a \x3c ",") {\n        discard;\n      }\n\n      ","\n      ","\n    }\n  "],["\n    void main() {\n      discardBySlice(vpos);\n      vec4 color \x3d ","\n      color \x3d highlightSlice(color, vpos);\n\n      ","\n\n      if (color.a \x3c ",") {\n        discard;\n      }\n\n      ","\n      ",
"\n    }\n  "])),c.attributeColor?"vColor * matColor;":"matColor;",0===c.output?b.glsl(x||(x=d.__makeTemplateObject(["color.a *\x3d ",";"],["color.a *\x3d ",";"])),G(c)):"",b.glsl.float(E.symbolAlphaCutoff),0===c.output?b.glsl(y||(y=d.__makeTemplateObject(["gl_FragColor \x3d color;"],["gl_FragColor \x3d color;"]))):"",4===c.output?b.glsl(z||(z=d.__makeTemplateObject(["outputHighlight();"],["outputHighlight();"]))):""));return a};var k,l,m,n,q,r,p,t,u,v,x,y,z,w,f,g,h});