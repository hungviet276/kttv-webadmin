// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.17/esri/copyright.txt for details.
//>>built
define("require exports tslib ../shading/EvaluateMainLighting.glsl ../shading/Water.glsl ../../shaderModules/interfaces".split(" "),function(n,e,c,l,m,d){Object.defineProperty(e,"__esModule",{value:!0});e.Overlay=void 0;e.Overlay=function(a,b){3!==b.pbrMode&&4!==b.pbrMode||a.include(m.Water,b);a.vertex.uniforms.add("overlayTexOffset","vec4");a.vertex.uniforms.add("overlayTexScale","vec4");a.varyings.add("vtcOverlay","vec4");a.vertex.code.add(d.glsl(f||(f=c.__makeTemplateObject(["\n    void setOverlayVTC(in vec2 uv) {\n      vtcOverlay \x3d vec4(uv, uv) * overlayTexScale + overlayTexOffset;\n    }\n  "],
["\n    void setOverlayVTC(in vec2 uv) {\n      vtcOverlay \x3d vec4(uv, uv) * overlayTexScale + overlayTexOffset;\n    }\n  "]))));a.fragment.uniforms.add("ovInnerColorTex","sampler2D");a.fragment.uniforms.add("ovOuterColorTex","sampler2D");a.fragment.uniforms.add("overlayOpacity","float");a.fragment.code.add(d.glsl(g||(g=c.__makeTemplateObject(["\n    vec4 getOverlayColor(sampler2D ov0Tex, sampler2D ov1Tex, vec4 texCoords) {\n      // read textures outside of conditions, to avoid artifacts likely related to non-uniform flow control:\n      // - https://www.khronos.org/opengl/wiki/Sampler_(GLSL)#Non-uniform_flow_control\n      // - https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/13657\n      vec4 color0 \x3d texture2D(ov0Tex, texCoords.xy);\n      vec4 color1 \x3d texture2D(ov1Tex, texCoords.zw);\n\n      float valid0 \x3d float((texCoords.x \x3e\x3d 0.0) \x26\x26 (texCoords.x \x3c\x3d 1.0) \x26\x26 (texCoords.y \x3e\x3d 0.0) \x26\x26 (texCoords.y \x3c\x3d 1.0));\n      float valid1 \x3d float((texCoords.z \x3e\x3d 0.0) \x26\x26 (texCoords.z \x3c\x3d 1.0) \x26\x26 (texCoords.w \x3e\x3d 0.0) \x26\x26 (texCoords.w \x3c\x3d 1.0));\n\n      // Pick color0 if valid, otherwise color1 if valid, otherwise vec4(0)\n      return mix(color1 * valid1, color0, valid0);\n    }\n  "],
["\n    vec4 getOverlayColor(sampler2D ov0Tex, sampler2D ov1Tex, vec4 texCoords) {\n      // read textures outside of conditions, to avoid artifacts likely related to non-uniform flow control:\n      // - https://www.khronos.org/opengl/wiki/Sampler_(GLSL)#Non-uniform_flow_control\n      // - https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/13657\n      vec4 color0 \x3d texture2D(ov0Tex, texCoords.xy);\n      vec4 color1 \x3d texture2D(ov1Tex, texCoords.zw);\n\n      float valid0 \x3d float((texCoords.x \x3e\x3d 0.0) \x26\x26 (texCoords.x \x3c\x3d 1.0) \x26\x26 (texCoords.y \x3e\x3d 0.0) \x26\x26 (texCoords.y \x3c\x3d 1.0));\n      float valid1 \x3d float((texCoords.z \x3e\x3d 0.0) \x26\x26 (texCoords.z \x3c\x3d 1.0) \x26\x26 (texCoords.w \x3e\x3d 0.0) \x26\x26 (texCoords.w \x3c\x3d 1.0));\n\n      // Pick color0 if valid, otherwise color1 if valid, otherwise vec4(0)\n      return mix(color1 * valid1, color0, valid0);\n    }\n  "]))));
a.fragment.code.add(d.glsl(h||(h=c.__makeTemplateObject(["\n    vec4 getCombinedOverlayColor() {\n      return overlayOpacity * getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n    }\n  "],["\n    vec4 getCombinedOverlayColor() {\n      return overlayOpacity * getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n    }\n  "]))));if(3===b.pbrMode||4===b.pbrMode)a.include(l.EvaluateMainLighting),a.fragment.code.add(d.glsl(k||(k=c.__makeTemplateObject(["\n    vec4 getOverlayWaterColor(vec4 maskInput, vec4 colorInput, vec3 vposEyeDir,\n       float shadow, vec3 localUp, mat3 tbn, vec3 position) {\n\n      // reproject normal from 0...1 \x3d\x3e -1...1\n      // and project it to worldspace.\n      vec3 n \x3d normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));\n      vec3 v \x3d vposEyeDir;\n      vec3 l \x3d normalize(-lightingMainDirection);\n      vec3 final \x3d getSeaColor(n, v, l, colorInput.rgb, lightingMainIntensity, localUp, 1.0 - shadow, maskInput.w, position);\n\n      // the terrain renderer assumes a premultiplied color output without gamma.\n      return vec4(final, colorInput.w);\n    }\n    "],
["\n    vec4 getOverlayWaterColor(vec4 maskInput, vec4 colorInput, vec3 vposEyeDir,\n       float shadow, vec3 localUp, mat3 tbn, vec3 position) {\n\n      // reproject normal from 0...1 \x3d\x3e -1...1\n      // and project it to worldspace.\n      vec3 n \x3d normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));\n      vec3 v \x3d vposEyeDir;\n      vec3 l \x3d normalize(-lightingMainDirection);\n      vec3 final \x3d getSeaColor(n, v, l, colorInput.rgb, lightingMainIntensity, localUp, 1.0 - shadow, maskInput.w, position);\n\n      // the terrain renderer assumes a premultiplied color output without gamma.\n      return vec4(final, colorInput.w);\n    }\n    "]))))};
var f,g,h,k});